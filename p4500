#!/usr/bin/python -B

import os
import sys

from config import *
import utils
import comparator
import normalize


def check_args():
  """Checks the command line arguments.

  Prints a message to standard error if the arguments are incorrect.

  Returns:
    True if the arguments are correct; otherwise False.
  """
  usage = ['ERROR  {0} -f <path> -f <path>\n',
           'ERROR  {0} -f <path> -d <path>\n',
           'ERROR  {0} -d <path> -f <path>\n',
           'ERROR  {0} -d <path> -d <path>\n']
  args_good = (len(sys.argv) == 5 and 
               ((sys.argv[1] == '-f' and os.path.isfile(sys.argv[2])) or
                (sys.argv[1] == '-d' and os.path.isdir(sys.argv[2]))) and
               ((sys.argv[3] == '-f' and os.path.isfile(sys.argv[4])) or
                (sys.argv[3] == '-d' and os.path.isdir(sys.argv[4]))))
  if not args_good:
    sys.stderr.write('ERROR Usage: one of\n')
    sys.stderr.writelines([s.format(sys.argv[0]) for s in usage])
    return False
  return True


def check_file(path):
  """Checks if a given file is in either MP3 or WAVE format.

  Prints a message to standard error if the file is not in either format.

  Args:
    path: The path to the file to be checked.

  Returns:
    True if the file is in either MP3 or WAVE format; otherwise False.
  """
  if not (utils.is_mp3(path) or utils.is_wave(path)):
    sys.stderr.write('ERROR {0}: invalid format for {1}: input files must be '
                     'of MP3 or WAVE format\n'.format(sys.argv[0], path))
    return False
  return True


def get_paths(is_file, path):
  """Returns a list of file paths described by a path.

  Args:
    is_file: Whether the path names a regular file or a directory.
    path: The path to investigate.

  Returns:
    If is_file is true, a list containing path; otherwise, a list
    containing the contents of the directory named by path.
  """
  if is_file:
    return [path]
  path = os.path.normpath(path)
  return [os.path.join(path, f) for f in os.listdir(path)]


def main():
  # Check if syntax is correct
  if not check_args():
    sys.exit(1)
  # Verify format of input files
  paths1 = get_paths(sys.argv[1] == '-f', sys.argv[2])
  paths2 = get_paths(sys.argv[3] == '-f', sys.argv[4])
  # Filter out input of improper format
  good_paths1 = [f for f in paths1 if check_file(f)]
  good_paths2 = [f for f in paths2 if check_file(f)]
  # Stop here if at least one group of files is empty
  if not good_paths1 or not good_paths2:
    sys.exit(1)
  # Normalize remaining files
  normalized1 = [normalize.normalize_file(f) for f in good_paths1]
  normalized2 = [normalize.normalize_file(f) for f in good_paths2]
  # Compute the FFTs and MFCCs of all normalized files
  data1 = [normalize.get_mfcc(f.name) for f in normalized1]
  data2 = [normalize.get_mfcc(f.name) for f in normalized2]
  # Check for matches between all possible pairs of files
  for i in range(0, len(data1)):
    fft1, ceps1 = data1[i]
    f1 = os.path.basename(good_paths1[i])
    for j in range(0, len(data2)):
      fft2, ceps2 = data2[j]
      f2 = os.path.basename(good_paths2[j])
      match = (comparator.compare(fft1, fft2, FFT_MATCH_THRESHOLD) or
               comparator.compare(ceps1, ceps2, MFCC_MATCH_THRESHOLD))
      if match:
        print 'MATCH {0} {1}'.format(f1, f2)
      else:
        print 'NO MATCH'
  # Close and delete all generated temp files
  for f in normalized1:
    f.close()
  for f in normalized2:
    f.close()
  # Exit with error code 1 if any input files were in an improper format
  if len(paths1) != len(good_paths1) or len(paths2) != len(good_paths2):
    sys.exit(1)


if __name__ == '__main__':
  main()
