#!/usr/bin/python -B

import os
import sys

from config import *
import utils
import comparator
import normalize


def check_args():
  """Checks the command line arguments.

  Prints a message to standard error if the arguments are incorrect.

  Returns:
    True if the arguments are correct; otherwise False.
  """

  args_good = (len(sys.argv) == 5 
               and 
               (
                 (sys.argv[1] == '-f' and os.path.isfile(sys.argv[2])) 
                 or
                 (sys.argv[1] == '-d' and os.path.isdir(sys.argv[2]))
               ) 
               and
               (
                 (sys.argv[3] == '-f' and os.path.isfile(sys.argv[4])) 
                 or
                 (sys.argv[3] == '-d' and os.path.isdir(sys.argv[4]))
               )
              )

  if not args_good:
    sys.stderr.write('ERROR Usage: {0} <flag1> <path1> <flag2> <path2>\n'
                     .format(sys.argv[0]))
    return False
  return True 


def check_file(path):
  """Checks if a given file is in either MP3 or WAVE format.

  Prints a message to standard error if the file is not in either format.

  Args:
    path: The path to the file to be checked.

  Returns:
    True if the file is in either MP3 or WAVE format; otherwise False.
  """
  if not (utils.is_mp3(path) or utils.is_wave(path)):
    sys.stderr.write(
      'ERROR Usage on {0}: input files must be of MP3 or WAVE format\n'
      .format(utils.quote(path))
    )
    return False
  return True


def main():
  # Check if syntax is correct
  if not check_args():
    sys.exit(1)

  # Verify format of input files
  bad_input = False
  path1_files = []
  path2_files = []

  if (sys.argv[1] == '-f'):
    path1_files = [sys.argv[2]]
  else:
    # Strip off any trailing '/'s from the directory name
    while sys.argv[2].endswith('/'):
      sys.argv[2] = sys.argv[2][:-1]
    path1_files = [sys.argv[2] + '/' + f for f in os.listdir(sys.argv[2])]

  if (sys.argv[3] == '-f'):
    path2_files = [sys.argv[4]]
  else:
    # Strip off any trailing '/'s from the directory name
    while sys.argv[4].endswith('/'):
      sys.argv[4] = sys.argv[4][:-1]
    path2_files = [sys.argv[4] + '/' + f for f in os.listdir(sys.argv[4])]

  # Filter out input of improper format
  good_path1_files = [f for f in path1_files if check_file(f)]
  good_path2_files = [f for f in path2_files if check_file(f)]

  # Stop here if at least one group of files is empty
  if (len(good_path1_files) == 0 or len(good_path2_files) == 0):
    sys.exit(1)

  # Normalize remaining files
  normalized1 = [normalize.normalize_file(f) for f in good_path1_files]
  normalized2 = [normalize.normalize_file(f) for f in good_path2_files]

  # Compute the FFTs and MFCCs of all normalized files
  path1_data = [normalize.get_mfcc(f.name) for f in normalized1]
  path2_data = [normalize.get_mfcc(f.name) for f in normalized2]
      
  # Check for matches between all possible pairs of files
  for i in range(0, len(path1_data)):
    fft1, ceps1 = path1_data[i]
    f1 = good_path1_files[i]

    for j in range(0, len(path2_data)):
      fft2, ceps2 = path2_data[j]
      f2 = good_path2_files[j]
  
      match = (comparator.compare(fft1, fft2, FFT_MATCH_THRESHOLD) or 
               comparator.compare(ceps1, ceps2, MFCC_MATCH_THRESHOLD))
      if match:
        print 'MATCH: {0} {1}'.format(utils.quote(f1), utils.quote(f2))
      else:
        print 'NO MATCH: {0} {1}'.format(utils.quote(f1), utils.quote(f2))
  
  # Close and delete all generated temp files
  for f in normalized1:
    f.close()
  for f in normalized2:
    f.close()

  # Exit with error code 1 if any input files were in an improper format
  if (len(path1_files) != len(good_path1_files) or 
      len(path2_files) != len(good_path2_files)):
    sys.exit(1)


if __name__ == '__main__':
  main()
